# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

get_VA_funcs <- function(data, parameters) {
    .Call(`_survTMB_get_VA_funcs`, data, parameters)
}

VA_funcs_eval_lb <- function(p, par) {
    .Call(`_survTMB_VA_funcs_eval_lb`, p, par)
}

VA_funcs_eval_grad <- function(p, par) {
    .Call(`_survTMB_VA_funcs_eval_grad`, p, par)
}

VA_funcs_eval_hess <- function(p, par) {
    .Call(`_survTMB_VA_funcs_eval_hess`, p, par)
}

VA_funcs_eval_hess_sparse <- function(p, par) {
    .Call(`_survTMB_VA_funcs_eval_hess_sparse`, p, par)
}

get_gl_rule <- function(n) {
    .Call(`_survTMB_get_gl_rule`, n)
}

#' Clears the Memory used by CppAD
#' Clear all pointers to CppAD objects and deallocate all memory used by
#' CppAD. This will make all subsequent use C++ pointer invalid.
#'
#' @param max_n_threads maximum number of threads which have been used.
#' @param keep_work_space logical for whether to keep
#'
#' @return An integer which is one if all memory could be freed.
#'
#' @export
clear_cppad_mem <- function(max_n_threads = 1L, keep_work_space = FALSE) {
    .Call(`_survTMB_clear_cppad_mem`, max_n_threads, keep_work_space)
}

set_n_threads <- function(n_threads) {
    .Call(`_survTMB_set_n_threads`, n_threads)
}

get_commutation <- function(n, m) {
    .Call(`_survTMB_get_commutation`, n, m)
}

get_gsm_pointer <- function(X, XD, Z, y, eps, kappa, link, n_threads, offset_eta, offset_etaD) {
    .Call(`_survTMB_get_gsm_pointer`, X, XD, Z, y, eps, kappa, link, n_threads, offset_eta, offset_etaD)
}

gsm_eval_ll <- function(ptr, beta, gamma) {
    .Call(`_survTMB_gsm_eval_ll`, ptr, beta, gamma)
}

gsm_eval_grad <- function(ptr, beta, gamma) {
    .Call(`_survTMB_gsm_eval_grad`, ptr, beta, gamma)
}

gsm_eval_hess <- function(ptr, beta, gamma) {
    .Call(`_survTMB_gsm_eval_hess`, ptr, beta, gamma)
}

get_herita_funcs <- function(data, parameters) {
    .Call(`_survTMB_get_herita_funcs`, data, parameters)
}

herita_funcs_eval_lb <- function(p, par) {
    .Call(`_survTMB_herita_funcs_eval_lb`, p, par)
}

herita_funcs_eval_grad <- function(p, par, out) {
    invisible(.Call(`_survTMB_herita_funcs_eval_grad`, p, par, out))
}

herita_get_size <- function(p) {
    .Call(`_survTMB_herita_get_size`, p)
}

joint_start_ll <- function(Y, tstart, tstop, omega, delta, Z, n_nodes, coefs, grad, use_log, basis_type) {
    .Call(`_survTMB_joint_start_ll`, Y, tstart, tstop, omega, delta, Z, n_nodes, coefs, grad, use_log, basis_type)
}

get_joint_funcs <- function(data, parameters) {
    .Call(`_survTMB_get_joint_funcs`, data, parameters)
}

joint_funcs_eval_lb <- function(p, par) {
    .Call(`_survTMB_joint_funcs_eval_lb`, p, par)
}

joint_funcs_eval_grad <- function(p, par) {
    .Call(`_survTMB_joint_funcs_eval_grad`, p, par)
}

get_orth_poly <- function(x, degree) {
    .Call(`_survTMB_get_orth_poly`, x, degree)
}

predict_orth_poly <- function(x, alpha, norm2) {
    .Call(`_survTMB_predict_orth_poly`, x, alpha, norm2)
}

fix_atomic_seqfault <- function() {
    invisible(.Call(`_survTMB_fix_atomic_seqfault`))
}

setup_atomic_cache <- function(n_nodes, type, triag_sizes, link = "") {
    invisible(.Call(`_survTMB_setup_atomic_cache`, n_nodes, type, triag_sizes, link))
}

